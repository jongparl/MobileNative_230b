<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
 <head> 
  <script type="text/javascript" src="../../snippet.js"></script> 
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /> 
  <link href="../../styles.css" rel="StyleSheet" type="text/css" /> 
  <link href="../../snippet.css" rel="StyleSheet" type="text/css" /> 
  <title>Push Tutorial</title> 
 </head> 
 <body onload="prettyPrint()"> 
  <!--<div id="banner">
Tizen</div>--> 
  <h1>Push Tutorial</h1> 

<p>The Tizen Push Service allows applications in a mobile device to receive notifications through the Internet even when the applications are not running.</p>

<p>API functions and data types are defined in the <span style="font-family: Courier New,Courier,monospace;">&lt;push-service.h&gt;</span> header file, which has to be included in all applications that use the <a href="../../../../org.tizen.mobile.native.apireference/group__CAPI__MESSAGING__PUSH__PUBLIC__MODULE.html">Push API</a>.</p>

<p>To learn about the Push API features, see the <a href="../../guide/messaging/push_messaging.htm">Push Messaging Programming Guide</a>.</p>

<p>This tutorial consists of the following parts:</p>
	<ul>
		<li><a href="#start">Initialization and Prerequisites</a>
		<p>Ensure that prerequisites are fulfilled and set up the required libraries.</p></li>
		<li><a href="#connect">Connecting to the Push Daemon</a>
		<p>Establish a socket connection to the push daemon.</p></li>
		<li><a href="#registration">Registering with the Push Server</a>
		<p>Register and unregister with the push server.</p></li>
		<li><a href="#dealing">Handling Push Notifications</a>
		<p>Receive notifications at different states.</p></li>
		<li><a href="#security">Managing Security</a>
		<p>Ensure the security of notifications containing sensitive information.</p></li>
   </ul>



<h2 id="start" name="start">Initialization and Prerequisites</h2>
<p>Make sure the following requirements are fulfilled:</p>
<ol>
<li>Internet access 
<p>To connect to the Tizen push server and receive notifications from it, your target device (or Emulator) must be able to contact any IP addresses with the port 5223. If you are in an enterprise network, ensure that the proxy setting in your local network allows outgoing traffic destined for this port number.</p></li>
<li>Package ID
<p>When you create your project in the Tizen SDK, you are given the package ID (randomly generated by the SDK or entered by yourself). The Tizen push server identifies your applications using the package ID.</p></li>
<li>Permission to Tizen push servers
<p>To use the push messaging service, the application needs the permission to access Tizen push server. Request the permission from the Tizen push service team by email (<a href="mailto:push.tizen@samsung.com">push.tizen@samsung.com</a>), including the following information. When the team approves your request, you receive a push app ID corresponding to your package ID.</p></li>
</ol>

<table>
<caption>Request form details</caption>
   <colgroup> 
    <col width="25%" /> 
    <col width="75%" /> 
   </colgroup> 
<tbody>
    <tr> 
     <th colspan="2">Developer information</th> 
    </tr> 
	 <tr> 
     <td rowspan="1" colspan="1"> <p>Email address</p> </td> 
     <td rowspan="1" colspan="1"> <p>Your email address to receive the approval response.</p> </td> 
	</tr>
	 <tr> 
     <td rowspan="1" colspan="1"> <p>Last name</p> </td> 
     <td rowspan="1" colspan="1"> <p>Your last name.</p> </td> 
	</tr>
	 <tr> 
     <td rowspan="1" colspan="1"> <p>First name</p></td> 
     <td rowspan="1" colspan="1"> <p>Your first name.</p> </td> 
	</tr>
	 <tr> 
     <td rowspan="1" colspan="1"> <p>Country</p> </td> 
     <td rowspan="1" colspan="1"> <p>Your country of residence.</p> </td> 
	</tr>
    <tr> 
     <th colspan="2">Application information</th> 
    </tr> 
	 <tr> 
     <td rowspan="1" colspan="1"> <p> Package ID </p> </td> 
     <td rowspan="1" colspan="1"> <p> The ID of the application package that uses the push messaging service. The package ID can be obtained from the <span style="font-family: Courier New,Courier,monospace">.xml</span> file in the Tizen SDK.  </p> </td> 
	</tr>
	 <tr> 
     <td rowspan="1" colspan="1"> <p> Application name </p> </td> 
     <td rowspan="1" colspan="1"> <p> Name of the application that uses the push service. </p> </td> 
	</tr>
	 <tr> 
     <td rowspan="1" colspan="1"> <p> Testing purpose </p> </td> 
     <td rowspan="1" colspan="1"> <p> Yes or no. If you request the service for testing purposes only, the duration of the push service is limited to 3 weeks. </p> </td> 
	</tr>
	 <tr> 
     <td rowspan="1" colspan="1"> <p> Purpose of the push notification usage </p> </td> 
     <td rowspan="1" colspan="1"> <p> Description of how you plan to use the push service, including the situations in which you want to use it. </p> </td> 
	</tr>
	 <tr> 
     <td rowspan="1" colspan="1"> <p> App launch date </p> </td> 
     <td rowspan="1" colspan="1"> <p> Application launch date in the YYYY/MM/DD format.<br />For example: 2012/08/01. </p> </td> 
	</tr>
	 <tr> 
     <td rowspan="1" colspan="1"> <p> Service area / country </p> </td> 
     <td rowspan="1" colspan="1"> <p> Service area (such as Asia, Africa, America, or Europe) or the country where the application is used. </p> </td> 
	</tr>
	 <tr> 
     <td rowspan="1" colspan="1"> <p> Daily push requests </p> </td> 
     <td rowspan="1" colspan="1"> <p> Estimated total number of daily notifications. </p> </td> 
	</tr>
	 <tr> 
     <td rowspan="1" colspan="1"> <p> Transactions per second </p> </td> 
     <td rowspan="1" colspan="1"> <p> Estimated peak number of transactions per second (the recommendation is below 100). </p> </td> 
	</tr>
</tbody>
</table>


<p>Set up the required library and privilege for your application:</p>
<ol>
<li><p>To use APIs for the Tizen push service, include <span style="font-family: Courier New,Courier,monospace;">push-service.h</span> to your source code:</p>

<pre class="prettyprint">
#include &lt;push-service.h&gt;
</pre>
</li>

<li id="privilege" name="privilege"><p>To access the Tizen push daemon on the device, add the following privilege to the manifest file:
</p>

<pre class="prettyprint">
http://tizen.org/privilege/push
</pre>
</li>
</ol>

<h2 id="connect" name="connect">Connecting to the Push Daemon</h2>
<p>To request or receive push notifications, establish a socket connection to the push daemon. All the information regarding this connection must be controlled by a connection handle which can be defined as a global variable:</p>

<pre class="prettyprint">
push_service_connection_h push_conn;
</pre>

<p>To manage push daemon connections:</p>
<ol>
<li>Connect to the push daemon.
<p>Once the connection handle is defined, use the <span style="font-family: Courier New,Courier,monospace;">push_service_connect()</span> function to connect the push daemon: </p>

<pre class="prettyprint">
#include &lt;dlog.h&gt;

#define PUSH_APP_ID &quot;YOUR_PUSH_ID_HERE&quot;
#define DLOG_TAG &quot;PushSample&quot;

static bool app_create(void *data)
{
&nbsp;&nbsp;&nbsp;int ret;

&nbsp;&nbsp;&nbsp;// Connect to the push daemon when the application is launched
&nbsp;&nbsp;&nbsp;ret = push_service_connect(PUSH_APP_ID, _state_cb, _noti_cb, NULL, &amp;push_conn);

&nbsp;&nbsp;&nbsp;if (ret != PUSH_SERVICE_ERROR_NONE) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Your implementation here
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, DLOG_TAG, &quot;push_service_connect() Failed&quot;);
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;return true;
}
</pre>

<p>In the above example, the application establishes a socket connection to the push daemon using the <span style="font-family: Courier New,Courier,monospace;">push_service_connect()</span> function. The <span style="font-family: Courier New,Courier,monospace;">YOUR_PUSH_ID_HERE</span> argument is the push app ID received from the Tizen push server team when the access to the server was requested. Keep this push app ID confidential, otherwise your push notifications can be hijacked by malicious applications.</p>
<p>The <span style="font-family: Courier New,Courier,monospace;">_state_cb()</span> and <span style="font-family: Courier New,Courier,monospace;">_noti_cb()</span> parameters are callback functions called when the <a href="#state">state changes</a> or <a href="#dealing">a notification arrives from the server</a> through the push daemon.</p>

<p>The <span style="font-family: Courier New,Courier,monospace;">push_conn</span> parameter is the output of the <span style="font-family: Courier New,Courier,monospace;">push_service_connect()</span> function. If the connection between your application and the daemon is successful, the <span style="font-family: Courier New,Courier,monospace;">push_service_connect()</span> functions returns <span style="font-family: Courier New,Courier,monospace;">PUSH_SERVICE_ERROR_NONE</span> and the <span style="font-family: Courier New,Courier,monospace;">push_conn</span> connection handle is returned through the last parameter. If the <span style="font-family: Courier New,Courier,monospace;">push_service_connect()</span> function returns other values, the connection to the daemon failed. This happens most likely when the <a href="#privilege">push privilege</a> is not added in the SDK.</p>

<p>In general, applications establish a connection to the daemon when they are launched and disconnect it when they terminate. Due to this reason, the <span style="font-family: Courier New,Courier,monospace;">push_service_connect()</span> function is located in the <span style="font-family: Courier New,Courier,monospace;">app_create()</span> function, which is called when the application is launched.
</p>
</li>

<li>Disconnect from the push daemon.
<p>When the application terminates or no longer uses the push service, close the connection.</p>
<p>The <span style="font-family: Courier New,Courier,monospace;">push_service_disconnect()</span> function closes the existing connection associated with the <span style="font-family: Courier New,Courier,monospace;">push_conn</span> handle and returns all the resources allocated for the connection.</p>

<pre class="prettyprint">
static void app_terminate(void *data)
{
&nbsp;&nbsp;&nbsp;push_service_disconnect(push_conn);
&nbsp;&nbsp;&nbsp;push_conn = NULL;
}
</pre>

<p>In general, the connection is closed when the application terminates. Hence, the <span style="font-family: Courier New,Courier,monospace;">push_service_disconnect()</span> is located in the <span style="font-family: Courier New,Courier,monospace;">app_terminate()</span> function, which is called just before the application terminates. However, you can disconnect the daemon in the middle of the application operation. If you add a toggle switch to your application for switching the push service on and off, call this function when the service is switched off.</p>
</li>

<li id="state" name="state">Handle state transitions.
<p>After the connection to the daemon is made, your application is notified whenever the connection state changes. This notification is conducted through the <span style="font-family: Courier New,Courier,monospace;">_state_cb()</span> callback, which is defined in the <span style="font-family: Courier New,Courier,monospace;">push_service_connect()</span> function. The following figure illustrates the possible states.</p>

<p style="text-align:center;"><img alt="State transitions" src="../../images/push_state_transitions.png" /></p>

<p>Once launched, your application is in the INITIAL state. When the application establishes connection to the daemon using the <span style="font-family: Courier New,Courier,monospace;">push_service_connect()</span> function, the state becomes either UNREGISTERED or REGISTERED:</p>
<ul><li>If your application is currently registered to the push server, the daemon forces your application to transit to the REGISTERED state.</li>
<li>If your application is not currently registered to the push server, the state transits to UNREGISTERED. In this case, your application can request registration to the push server through the push daemon using the <span style="font-family: Courier New,Courier,monospace;">push_service_register()</span> function. If this request is approved by the push server, the state transits to REGISTERED.</li></ul>

<p>If your application requests deregistration using the <span style="font-family: Courier New,Courier,monospace;">push_service_deregister()</span> function at the REGISTERED state, the state transits to the UNREGISTERED state. Both states imply that your application is connected to the push daemon. However, these states do not necessarily mean that the push daemon is connected to the push server.</p>
<p>Your application can receive push notifications only if it is in the REGISTERED state. Whenever the <span style="font-family: Courier New,Courier,monospace;">push_service_disconnect()</span> function is called in both states, the state transits back to the INITIAL state. When an error occurs in either state, your application moves to the ERROR state.</p>

<p>When the current state transits, the <span style="font-family: Courier New,Courier,monospace;">_state_cb()</span> function is called and the new state is obtained from the first argument. The application then needs to determine its actions based on the new state:</p>

<pre class="prettyprint">
static void _state_cb(push_service_state_e state, const char *err, void *user_data)	
{
&nbsp;&nbsp;&nbsp;switch (state)	
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case PUSH_SERVICE_STATE_UNREGISTERED:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, DLOG_TAG, &quot;Arrived at STATE_UNREGISTERED&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_on_state_unregistered(user_data);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case PUSH_SERVICE_STATE_REGISTERED:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, DLOG_TAG, &quot;Arrived at STATE_REGISTERED&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_on_state_registered(user_data);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case PUSH_SERVICE_STATE_ERROR:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, DLOG_TAG, &quot;Arrived at STATE_ERROR&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_on_state_error(err, user_data);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, DLOG_TAG, &quot;Unknown State&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;}
}
</pre>

<p>In the above example, the <span style="font-family: Courier New,Courier,monospace;">_on_state_registered()</span>, <span style="font-family: Courier New,Courier,monospace;">_on_state_unregistered()</span>, and <span style="font-family: Courier New,Courier,monospace;">_on_state_error()</span> functions contain the actions for the REGISTERED, UNREGISTERD, and ERROR states, respectively. Make sure that there is no <span style="font-family: Courier New,Courier,monospace;">PUSH_SERVICE_STATE_INITIAL</span> enum value for the INITIAL state. The second argument,  <span style="font-family: Courier New,Courier,monospace;">err</span>, is the error message from the push daemon when the state becomes ERROR. Consequently, only the <span style="font-family: Courier New,Courier,monospace;">_on_state_error()</span> function takes this argument while others ignore it.</p>
</li>
</ol>

<h2 id="registration" name="registration">Registering with the Push Server</h2>
<p>To receive push notifications, your application must send a registration request to the push server. When the server receives this request, it assigns a registration ID that is unique to your application on the particular device. When sending a notification from your application server, this registration ID is used as a destination address of your application. If your application no longer needs to receive push notifications, it sends a deregistration request to the server.</p>

<ol>
<li>Request registration.
<p>After connecting to the push daemon, request registration using the <span style="font-family: Courier New,Courier,monospace;">push_service_register()</span> function.</p>
<p>The function takes 3 arguments. The first argument is the connection handle that was returned from the <span style="font-family: Courier New,Courier,monospace;">push_service_connect()</span> function. The second argument is the callback function that returns the result of this registration request. The last argument is the user data to be handed over to the result callback function. </p>

<pre class="prettyprint">
static void _on_state_unregistered(void *user_data) 
{
&nbsp;&nbsp;&nbsp;int ret;

&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, DLOG_TAG, &quot;Unregistered CB started&quot;);

&nbsp;&nbsp;&nbsp;// Send a registration request to the Push daemon
&nbsp;&nbsp;&nbsp;ret = push_service_register(push_conn, _result_cb, NULL);
&nbsp;&nbsp;&nbsp;if (ret != PUSH_SERVICE_ERROR_NONE)	
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, DLOG_TAG, &quot;ERROR [%d]: push_service_register()&quot;, ret);
&nbsp;&nbsp;&nbsp;}
}
</pre>

<p>Note that the registration request is non-blocking. If <span style="font-family: Courier New,Courier,monospace;">PUSH_SERVICE_ERROR_NONE</span> returns from the <span style="font-family: Courier New,Courier,monospace;">push_service_register()</span> function, your request is successfully delivered to the push daemon. However, it does not necessarily mean that your request is approved by the server. If the push daemon successfully sends your request to the server and receives an approval, the <span style="font-family: Courier New,Courier,monospace;">_result_cb()</span> callback is called with <span style="font-family: Courier New,Courier,monospace;">PUSH_SERVICE_RESULT_SUCCESS</span> from the first parameter:</p>

<pre class="prettyprint">
static void _result_cb(push_service_result_e result, const char *msg, void *user_data) 
{
&nbsp;&nbsp;&nbsp;if (result == PUSH_SERVICE_RESULT_SUCCESS)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, DLOG_TAG, &quot;Registration request is approved.&quot;);
&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, DLOG_TAG, &quot;Registration ERROR [%s]&quot;, msg);
&nbsp;&nbsp;&nbsp;return;
}
</pre>

<p>When an error occurs in the middle of the registration process, the reason is returned from the first parameter of the callback. For example, if the network is offline, the <span style="font-family: Courier New,Courier,monospace;">push_service_register()</span> function returns <span style="font-family: Courier New,Courier,monospace;">PUSH_SERVICE_ERROR_NONE</span> (because delivery to the daemon is successful), but the <span style="font-family: Courier New,Courier,monospace;">_result_cb()</span> function is called later with <span style="font-family: Courier New,Courier,monospace;">PUSH_RESULT_TIMEOUT</span>. In this case, your application does not need to request registration again because the push daemon keeps the previous request and sends it when the network becomes online. The last parameter is the error message from the push daemon if the request fails.</p>

<p>The <span style="font-family: Courier New,Courier,monospace;">_on_state_unregistered()</span> function containing the <span style="font-family: Courier New,Courier,monospace;">push_service_register()</span> function is called when the state transits to UNREGISTERED. This application is designed to send the registration request as soon as it is connected to the push daemon. If your application requires users to login to your service, the registration request must be sent after the login process is complete.
</p>
</li>

<li id="upon" name="upon">
<p>Whenever your registration request is approved or your already-registered application is connected to the daemon, the <span style="font-family: Courier New,Courier,monospace;">_state_cb()</span> callback is called with <span style="font-family: Courier New,Courier,monospace;">PUSH_SERVICE_STATE_REGISTERED</span>. The application <a href="#state">calls the <span style="font-family: Courier New,Courier,monospace;">_on_state_registered()</span> function</a> immediately. Although it is your choice to determine the actions inside the function, the following example shows the actions that you need to bear in mind:</p>

<pre class="prettyprint">
#include &lt;badge.h&gt;

static void _on_state_registered(void *user_data) 
{
&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;char *reg_id = NULL;
&nbsp;&nbsp;&nbsp;char *app_id = NULL;

&nbsp;&nbsp;&nbsp;// Request unread notifications to the push daemon 
&nbsp;&nbsp;&nbsp;// _noti_cb() is called if there are unread notifications
&nbsp;&nbsp;&nbsp;ret = push_service_request_unread_notification(push_conn);

&nbsp;&nbsp;&nbsp;// If the request for unread notifications is successfully delivered,
&nbsp;&nbsp;&nbsp;// remove the badge count of this app
&nbsp;&nbsp;&nbsp;if (ret == PUSH_SERVICE_ERROR_NONE)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret = app_get_id(&amp;app_id);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (ret == APP_ERROR_NONE)	
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret = badge_remove(app_id);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (app_id)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(app_id);
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;// Get the registration ID
&nbsp;&nbsp;&nbsp;ret = push_service_get_registration_id(push_conn, &amp;reg_id);
&nbsp;&nbsp;&nbsp;if (ret != PUSH_SERVICE_ERROR_NONE)	
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, DLOG_TAG, &quot;ERROR [%d]: push_service_get_registration_id()&quot;, ret);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;// Send reg_id to your application server if necessary
&nbsp;&nbsp;&nbsp;_send_reg_id_if_necessary(reg_id);

&nbsp;&nbsp;&nbsp;free(reg_id);
}
</pre>

<p>First, you asynchronously request notifications that have arrived before the application is launched. If there is such a notification, it can be received through the <span style="font-family: Courier New,Courier,monospace;">_noti_cb()</span> function after the <span style="font-family: Courier New,Courier,monospace;">_on_state_registered()</span> function returns. Once your request for unread notifications is successfully delivered, <span style="font-family: Courier New,Courier,monospace;">PUSH_SERVICE_ERROR_NONE</span> is returned. In this case, remember to remove the badge count on your application icon that shows the number of unread notifications.</p>
<p>Secondly, retrieve the registration ID from the <span style="font-family: Courier New,Courier,monospace;">push_conn</span> connection handle. If the ID is new or updated, you need to send it to your application server. This ID is used as a destination address to your application in a particular device. If your application has already sent the ID before, you can skip this step. This logic is implemented in the <span style="font-family: Courier New,Courier,monospace;">_send_reg_id_if_necessary()</span> function:</p>

<pre class="prettyprint">
#include &lt;openssl/sha.h&gt;
#define PUSH_HASH_KEY &quot;existing_push_reg_id&quot;

static void _send_reg_id_if_necessary(const char *reg_id) 
{
&nbsp;&nbsp;&nbsp;char *hash_value = NULL;
&nbsp;&nbsp;&nbsp;char *stored_hash_value = NULL;
&nbsp;&nbsp;&nbsp;unsigned char md[SHA_DIGEST_LENGTH];
&nbsp;&nbsp;&nbsp;int ret;

&nbsp;&nbsp;&nbsp;// Generate a hash string from reg_id
&nbsp;&nbsp;&nbsp;hash_value = (char *) SHA1((unsigned char *)reg_id, sizeof(reg_id), md);
&nbsp;&nbsp;&nbsp;if (!hash_value) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, DLOG_TAG, &quot;Hash value is NULL&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, DLOG_TAG, &quot;Get hash [%s][%p]&quot;, md, md);

&nbsp;&nbsp;&nbsp;// Get the saved hash string
&nbsp;&nbsp;&nbsp;ret = preference_get_string(PUSH_HASH_KEY, &amp;stored_hash_value);

&nbsp;&nbsp;&nbsp;// If there is no hash string stored before or
&nbsp;&nbsp;&nbsp;// if the stored hash string is different from the new one,
&nbsp;&nbsp;&nbsp;// send reg_id to the server
&nbsp;&nbsp;&nbsp;if (ret != PREFERENCE_ERROR_NONE || strcmp(stored_hash_value, hash_value)!=0) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Your implementation here to send reg_id
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// to your app server
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret = _send_reg_id(reg_id);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// If reg_id is successfully sent,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// store the new hash value
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!ret) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret  = preference_set_string(PUSH_HASH_KEY, hash_value);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (ret != PREFERENCE_ERROR_NONE)	
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, DLOG_TAG, &quot;Fail to save hash_value&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;if (stored_hash_value) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(stored_hash_value);
&nbsp;&nbsp;&nbsp;// Do not free hash_value which is pointing to md
&nbsp;&nbsp;&nbsp;return;
}
</pre>

<p>The above example shows how to check whether the registration ID is new or updated. For security, it is not safe to keep your ID as a string because it can be easily exposed. Compute the hash value of the ID and compare it to the existing hash value. If they are different, your current ID is different from the previous one. In that case, send the registration ID to your application server and stores the new hash value. If they are the same, your application server already has this registration ID and the application can exit this function.</p>
</li>

<li>Request deregistration.
<p>When your application no longer wants to receive push notifications, use the following function to request deregistration:</p>

<pre class="prettyprint">
push_service_deregister(push_conn, _dereg_result_cb, NULL);
</pre>

<p>This function is non-blocking. If <span style="font-family: Courier New,Courier,monospace;">PUSH_SERVICE_ERROR_NONE</span> returns from this function, the request is successfully received by the push daemon. The result of this request is returned in the <span style="font-family: Courier New,Courier,monospace;">_dereg_result_cb()</span> callback function. The third argument is the pointer to user data that is handed over to the result function.</p>

<p>Note that the <span style="font-family: Courier New,Courier,monospace;">push_service_deregister()</span> function is not used, if the application is intended to receive push notifications while being installed. If the application is uninstalled, the push daemon detects the event and deregisters the application automatically. In contrast, if the application wants to receive push notifications only when a user logs in, the <span style="font-family: Courier New,Courier,monospace;">push_service_deregister()</span> function must be called whenever a user logs out.</p>
</li>
</ol>

<h2 id="dealing" name="dealing">Handling Push Notifications</h2>
<p>When a notification arrives at the device, it is delivered to the destination application in a different manner depending on whether the application is running:</p>

<ol>
<li id="receive" name="receive">Receive notifications when the application is running.
<p>When a notification arrives to your application while it is running (precisely, your application is connected to the daemon), the <span style="font-family: Courier New,Courier,monospace;">_noti_cb()</span> function is called as defined in the <span style="font-family: Courier New,Courier,monospace;">push_service_connect()</span> function. In this callback function, you can handle the received notification:</p>

<pre class="prettyprint">
static void _noti_cb(push_service_notification_h noti, void *user_data)
{
&nbsp;&nbsp;&nbsp;int ret;

&nbsp;&nbsp;&nbsp;char *data=NULL; // App data loaded on the notification
&nbsp;&nbsp;&nbsp;char *msg=NULL; // Noti message
&nbsp;&nbsp;&nbsp;long long int time_stamp; // Time when the noti is generated

&nbsp;&nbsp;&nbsp;if (!noti) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dlog_print(DLOG_ERROR, DLOG_TAG, &quot;Null Notification&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;// Retrieve app data from noti
&nbsp;&nbsp;&nbsp;ret = push_service_get_notification_data(noti, &amp;data);
&nbsp;&nbsp;&nbsp;// Your logic here to decrypt app data if it is encrypted

&nbsp;&nbsp;&nbsp;// Retrieve notification message from noti
&nbsp;&nbsp;&nbsp;ret = push_service_get_notification_message(noti, &amp;msg);

&nbsp;&nbsp;&nbsp;// Retrieve the time when notification is created from noti
&nbsp;&nbsp;&nbsp;ret = push_service_get_notification_time(noti, &amp;time_stamp);

&nbsp;&nbsp;&nbsp;// Your implementation here to use data, msg, and time_stamp

&nbsp;&nbsp;&nbsp;// Free all resources
&nbsp;&nbsp;&nbsp;// Do not free noti in the callback function
&nbsp;&nbsp;&nbsp;if (data)	
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(data);
&nbsp;&nbsp;&nbsp;if (msg)	
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(msg);
}
</pre>

<p>When the <span style="font-family: Courier New,Courier,monospace;">_noti_cb()</span> function is called, obtain the notification through the first parameter. The second parameter is the pointer to the user data. You can retrieve the app data, message, and time stamp from the handle using the <span style="font-family: Courier New,Courier,monospace;">push_get_notification_data()</span>, <span style="font-family: Courier New,Courier,monospace;">push_get_notification_message()</span>, and <span style="font-family: Courier New,Courier,monospace;">push_get_notification_time()</span> functions. Before exiting the function, free the data. However, do not free <span style="font-family: Courier New,Courier,monospace;">noti</span> in the notification callback function. It is freed automatically right after this callback function.</p>
</li>

<li>Receive notifications at launch.
<p>If the notification arrives when your application is not running, one option is to forcibly launch the application and deliver the notification as a bundle. For this scenario, set the option to be <span style="font-family: Courier New,Courier,monospace;">&quot;action=LAUNCH&quot;</span> when sending the notification from your application server. For more information, see the notification-sending guide that you receive separately from the Tizen push service team.</p>

<p>When a notification with the <span style="font-family: Courier New,Courier,monospace;">LAUNCH</span> action arrives at the push daemon, the daemon forcibly launches your application and delivers the notification data as a bundle. To receive the notification data when launched, call the <span style="font-family: Courier New,Courier,monospace;">push_service_app_control_to_noti_data()</span> function in the <span style="font-family: Courier New,Courier,monospace;">app_control()</span> function, which is a callback function that is triggered when your application is launched by another application or process.
</p>

<pre class="prettyprint">
static void app_control(app_control_h app_control, void *data)
{
&nbsp;&nbsp;&nbsp;char *op = NULL;
&nbsp;&nbsp;&nbsp;char *noti_data = NULL;

&nbsp;&nbsp;&nbsp;if (app_control_get_operation(app_control, &amp;op) &lt; 0) 
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, DLOG_TAG, &quot;operation : %s&quot;, op);

&nbsp;&nbsp;&nbsp;// Retrieve noti data from the bundle
&nbsp;&nbsp;&nbsp;noti_data = push_service_app_control_to_noti_data(app_control, op);
&nbsp;&nbsp;&nbsp;dlog_print(DLOG_DEBUG, DLOG_TAG, &quot;%s&quot;, noti_data);

&nbsp;&nbsp;&nbsp;if (noti_data) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(noti_data);

&nbsp;&nbsp;&nbsp;// Your implementation for the case when the process that launched
&nbsp;&nbsp;&nbsp;// this app is not the push daemon

&nbsp;&nbsp;&nbsp;if (op)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(op);
}
</pre>

<p>When you create your project in the SDK, the <span style="font-family: Courier New,Courier,monospace;">app_control()</span> function is created automatically. When your application is launched by the push daemon, all related information regarding this launch request is delivered through the <span style="font-family: Courier New,Courier,monospace;">app_control</span> argument. From this handle, retrieve the operation <span style="font-family: Courier New,Courier,monospace;">op</span> using the <span style="font-family: Courier New,Courier,monospace;">app_control_get_operation()</span> function. With <span style="font-family: Courier New,Courier,monospace;">app_control</span> and <span style="font-family: Courier New,Courier,monospace;">op</span>, retrieve the notification data using the <span style="font-family: Courier New,Courier,monospace;">push_service_app_control_to_noti_data()</span> function. If your application is not launched by the push daemon, this function returns <span style="font-family: Courier New,Courier,monospace;">NULL</span>. In this case, your own implementation must follow to handle this scenario.</p>
</li>

<li>Request unread notifications.
<p>When a notification arrives without the <span style="font-family: Courier New,Courier,monospace;">&quot;LAUNCH&quot;</span> option, the push daemon does not launch your application, but keeps it in the database. When your application is launched later, request these unread notifications either asynchronously or synchronously.</p>
 
<p>The asynchronous request using the <span style="font-family: Courier New,Courier,monospace;">push_service_request_unread_notification()</span> function is <a href="#upon">already introduced</a>. The synchronous request using the <span style="font-family: Courier New,Courier,monospace;">push_service_get_unread_notification()</span> function is shown below:
</p>

<pre class="prettyprint">
push_service_notification_h noti;

do 
{
&nbsp;&nbsp;&nbsp;push_service_get_unread_notification(push_conn, &amp;noti);
&nbsp;&nbsp;&nbsp;if (!noti)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;

&nbsp;&nbsp;&nbsp;// Your implementation to process unread message noti

&nbsp;&nbsp;&nbsp;push_server_free_notification(&amp;noti);
}
</pre>

<p>Call this function repeatedly until no notification is returned from the function. Note that the <span style="font-family: Courier New,Courier,monospace;">push_server_free_notification()</span> function blocks the code while it receives a notification from the daemon. Unless you need a synchronous behavior, the asynchronous function is recommended.</p>
</li>
</ol>

<h2 id="security" name="security">Managing Security</h2>
<p>When you send a notification with sensitive information, be aware of the chance that the notification is hijacked by someone else. It is your responsibility to keep such sensitive information safe from malicious access. The following instructions are strongly recommended:</p>

<ul>
<li>Keep your push app ID confidential. <p>If it is exposed, hackers can try to hijack your notifications using a fake application with the exposed ID.</p></li>
<li>Do not store the registration ID on the device. <p>This ID can be seen as a destination address of the notifications. Without this ID, hackers cannot send fake notifications to your application.</p></li>
<li>Do not hardcode your AppSecret in your source code. <p>AppSecret is a key to accessing the push server for sending notifications. If notifications are sent from your application server, your application does not need to know AppSecret at all. Keep AppSecret in the server and do not load any related information in your application. If you want device-to-device notification delivery without your application server, your application needs the AppSecret to send a notification from a device. In this case, it is your responsibility to keep AppSecret safe.</p></li>
<li>Encrypt sensitive information. <p>When you send sensitive information, such as personal information and financial transactions, encrypt it and load it to the notification as a payload. Do not load the information to the message field of the notification. When the notification arrives at the device, your application decrypts the payload and retrieves the sensitive information.</p></li>
</ul>

    <h2>Where to Go Next</h2> 
  <ul> 
	<li><a href="messaging_tutorial.htm">Messaging Tutorials</a></li>
	<li><a href="../../guide/messaging/push_messaging.htm">Push Messaging Programming Guide</a></li> 
	<li><a href="../../../../org.tizen.mobile.native.apireference/group__CAPI__MESSAGING__PUSH__PUBLIC__MODULE.html">Push API Reference</a></li>    
  </ul> 
 
  <div id="footer"> 
   <hr size="1" /> 
   <font size="1">Except as noted, this content - excluding the Code Examples - is licensed under <a href="http://creativecommons.org/licenses/by/3.0/legalcode" target="_blank">Creative Commons Attribution 3.0</a> and all of the Code Examples contained herein are licensed under <a href="https://www.tizen.org/bsd-3-clause-license" target="_blank">BSD-3-Clause</a>.<br>For details, see the <a href="https://www.tizen.org/content-license" target="_blank">Content License</a>.</font> 
  </div> 

  <script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-25976949-1']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script> 
 
 </body>
</html>